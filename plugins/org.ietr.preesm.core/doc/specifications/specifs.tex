\chapter{Preesm specifications}
\fancyhead[L,RO]{Preesm specifications}
\label{sec:specifs}

\begin{itemize}
\item Preesm is distributed as an Eclipse plug-in. The purpose of this plug-in is to contribute to the Eclipse environment to offer the user the possibility to create/edit/store/launch workflows in a Preesm project.
\item A workflow is a list of plug-ins that apply transformations to an algorithm, an architecture, or both. Algorithms and architectures may be modeled using Graphiti editor (which is not part of Preesm). Note that since a workflow may be seen as a simple directed acyclic graph it can also be edited using Graphiti. All that is needed is creating a new ontology in Graphiti to specify how workflows can be loaded/edited/saved.
\item A transformation plug-in must be an Eclipse plug-in that contributes to an extension point, say ``org.ietr.preesm.transformation''. This extension point defines an interface, say ``ITransformation''. Each transformation plug-in 
\end{itemize}

\section{Use case}

\begin{itemize}
	\item create a workflow
	\item apply this workflow to an algorithm and an architecture
\end{itemize}


\itemize
\item an algorithm with one or several TOP graphs 
\item an architecture on which this algorithm is executed
\item one set of parameter values for each TOP graph
\item one set of constraints for each couple \{TOP graph, Processing unit type\}
\item a list of directories containing libraries used by the project

\section{Mapping}

The mapping process can be automatic or semi-automatic. Before any automatic matching workflow, constraints can be applied to accelerate the mapping process. After an automatic mapping workflow has been launched, constraints can override the automatic mapping results.

\subsection{Constraints}
\subsubsection{What are implementation parameters?}

A constraint is a way to force functions to execute on a given processing unit.
TODO: Add timings 

\subsubsection{Add constraints on your project}

There are two graphical ways to add constraints to a project:

\itemize
\item the constraint graph 
\item the implementation graph 

\paragraph{the constraint graph}

The constraint graph allows the user to associate each operation with a processing unit. It constitutes a first step to constrain the algorithm and can be used strictly before automatic matching. Send and Receive vertexes appear when communication must be done between processing units. The view is hierarchical. The Send vertex is set close and at the same level than the data sending operation. The receive vertex is set close and at the same level than the data receiving operation.
TODO: define rules of multi-level send/receive display.

\paragraph{the implementation graph}

The implementation graph gives a fine control on the matching process. It gives the possibility to drag and drop each operation from one processing unit to another. The user can also drag and drop the Send and Receive vertices from one communicator to another when several are available. The temporal implementation graph can be used only after the automatic matching is finished.

\paragraph{Load and store constraints}

Constraints can be loaded from and stored to a .cst OWL based file.

\section{Mapping process}

\paragraph{Mapping Graph}

\section{Code Generation}

\subsection{Code generation using m4 code}
\subsection{Code generation using direct translation}
