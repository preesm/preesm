/**
 * Copyright or © or Copr. IETR/INSA - Rennes (2017 - 2020) :
 *
 * Alexandre Honorat [alexandre.honorat@inria.fr] (2019)
 * Antoine Morvan [antoine.morvan@insa-rennes.fr] (2017 - 2019)
 * Julien Heulot [julien.heulot@insa-rennes.fr] (2020)
 *
 * This software is a computer program whose purpose is to help prototyping
 * parallel applications using dataflow formalism.
 *
 * This software is governed by the CeCILL  license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 */
/*
 ============================================================================
 Name        : dump.h
 Author      : farresti, ahonorat, kdesnos, jhascoet
 Version     :
 Copyright   : CECILL-C
 Description : Function called by code generated by the Instrumented C
 Printer of Preesm
 ============================================================================
 */
#ifndef CLOCK_PREESM_H
#define CLOCK_PREESM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32

#include <windows.h>
// override uint64_t
#ifdef uint64_t
#undef uint64_t
#endif
typedef unsigned __int64 uint64_t;

#else

#include <stdint.h>

#endif

/**
 * Character string pointing to the "analysis.csv" file generated by Preesm
 * Instrumented C printer
 */
#define DUMP_FILE "analysis.csv"

#define MIN_TIME_MEASURE 1e5
#define MAX_ITER_MEASURE 10000

/**
 * Function used to dump the current processor time to the appropriate
 * place in the dumpBuffer.
 *
 * @param id
 *       The id of the current dump. Each id corresponds to a unique instant
 *       of the schedule generated by Preesm.
 * @param dumpBuffer
 *       This buffer stores all the timings dumped by calling the dumpTime
 function. This timings will be analyzed by the writeTime function.
 */
#ifdef _WIN32
static void dumpTime(int id, uint64_t* dumpBuffer);
#else
static inline void dumpTime(int id, uint64_t *dumpBuffer);
#endif

/**
 * Function used to analyze the timings dumped in the dumpBuffer and write the
 * result to the DUMP_FILE file.
 *
 * @param dumpBuffer
 *        This buffer stores all the timings dumped by calling the dumpTime
 *        function. This timings will be analyzed by the writeTime function.
 *
 * @param nbDump
 *        Total number of dumps of the program (i.e. size of dumpBuffer and
 *        nbExec arrays)
 *
 * @param nbExec
 *        This array stores a unique value for each dumpId corresponding to
 *        the number of times the function/actor preceeding this dump should be
 *        executed in order to get a significant time measure. This parameter
 *        is updated when calling the writeTime function.
 */
void writeTime(uint64_t *dumpBuffer, int nbDump, int *nbExec);

/**
 * Function used to initialize the analysis mechanism.
 * This function:
 * - Initialises the nbExec array with unitary values
 * - Opens/Creates the analysis csv file.
 *
 * @param nbExec
 *        This array stores a unique value for each dumpId corresponding to
 *        the number of times the function/actor preceeding this dump should be
 *        executed in order to get a significant time measure. This parameter
 *        is updated when calling the writeTime function.
 * @param nbDump
 *        Total number of dumps of the program (i.e. size of dumpBuffer and
 *        nbExec arrays)
 */
void initNbExec(int *nbExec, int nbDump);

#ifdef _WIN32


static void dumpTime(int id, uint64_t * dumpBuffer) {
    LARGE_INTEGER now;
    QueryPerformanceCounter(&now);
    dumpBuffer[id] = now.QuadPart;
}

static double getElapsedNanoSec(uint64_t *start, uint64_t *end) {
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    double elapsed = ((*end) - (*start)) * ((double) 1e9);
    return elapsed / frequency.QuadPart;
}


#elif defined(__APPLE__) && defined(__MACH__)

#include <mach/mach_time.h>

static inline void dumpTime(int id, uint64_t * dumpBuffer) {
	dumpBuffer[id] = mach_absolute_time();
}

static inline double getElapsedNanoSec(uint64_t *start, uint64_t *end) {
	mach_timebase_info_data_t timeBase;
	mach_timebase_info(&timeBase);
	double res = (double) timeBase.numer /	timeBase.denom;
	res *= ((*end) - (*start));
	return res;
}

#elif defined(DEVICE_C6678) || defined(SOC_C6678)

#include <ti/csl/csl_cacheAux.h>
#include <xdc/runtime/System.h>
#include <xdc/runtime/Types.h>
#include <xdc/runtime/Timestamp.h>

// needs xdc.useModule('xdc.runtime.Types') and xdc.useModule("xdc.runtime.Timestamp") in the .cfg file
static inline void dumpTime(int id, uint64_t * dumpBuffer) {
	// check if C6678 supports Timestamp64, otherwise, only the lo bits are set
	dumpBuffer[id] = Timestamp_get64(); // real type: Types_Timestamp64 being a struct of two Bits32 (hi and then lo)
	CACHE_wbInvL2(dumpBuffer+id, sizeof(uint64_t), CACHE_WAIT);
}

// Frequency of C6678 is 1,0 GHz or 1.25 GHz or 1.4 GHz
static inline double getElapsedNanoSec(uint64_t *start, uint64_t *end) {
	unit64_t freqHz; // real type: Types_FreqHz being a struct of two Bits32 (hi and then lo)
	Timestamp_getFreq(&freq);
	return ((*end) - (*start)) / (freq / ((double) 1e9));
}

#elif defined(__gnu_linux__) && _POSIX_C_SOURCE >= 199309L
// should be compiled with -std=gnu99 at least or have _GNU_SOURCE defined

// For Linux
// clock_gettime defined in POSIX 1999 version
// For the 1990 revision compliance the defined value of _POSIX_VERSION should be 1.
// For the 1995 revision compliance the defined value of _POSIX_VERSION should be 199506L.
// For the 2001 revision compliance the defined value of _POSIX_VERSION should be 200112L.


#include <time.h>

static inline void dumpTime(int id, uint64_t * dumpBuffer) {
    struct timespec clock;
    clock_gettime(CLOCK_MONOTONIC, &clock);
    dumpBuffer[id] = (uint64_t) (clock.tv_sec * 1e9) + clock.tv_nsec;
}

static inline double getElapsedNanoSec(uint64_t *start, uint64_t *end) {
    return ((*end) - (*start));
}

#else // Undefined or Unsupported platform, use clock as defined by C standard

#include <time.h>

static inline void dumpTime(int id, uint64_t *dumpBuffer) {
  dumpBuffer[id] = clock();
}

// clock diffs normally must be divided by CLOCKS_PER_SEC to have time in s
// however this macro always holds the value 1 000 000 thus clock() is in µs.
static inline double getElapsedNanoSec(uint64_t *start, uint64_t *end) {
  return ((*end) - (*start)) * 1e3;
}
#endif

#ifdef __cplusplus
}
#endif

#endif // CLOCK_PREESM_H
